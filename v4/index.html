<!DOCTYPE html>
<html>
<head>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .game-setup {
            position: fixed;
            top: -200px; /* Caché par défaut */
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            padding: 20px;
            background: white;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: top 0.3s ease;
            z-index: 1000;
        }

        /* Zone de détection du hover */
        .hover-zone {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 20px;
            z-index: 999;
        }

        /* Affiche le menu quand on hover sur la zone */
        .hover-zone:hover + .game-setup,
        .game-setup:hover {
            top: 0;
        }

        .players-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 20px;
        }

        .player-select {
            flex: 1;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        h3 {
            margin: 0 0 8px 0;
            color: #2d3436;
            font-size: 0.9em;
        }

        select {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            background-color: white;
            transition: border-color 0.3s ease;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23555' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 14px;
        }

        select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .button-container {
            text-align: center;
        }

        #start-game-btn {
            padding: 8px 24px;
            font-size: 14px;
            font-weight: 600;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #start-game-btn:hover:not(:disabled) {
            background-color: #45a049;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        #start-game-btn:disabled {
            background-color: #e0e0e0;
            cursor: not-allowed;
            box-shadow: none;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div class="hover-zone"></div>
    <div class="game-setup">
        <div class="players-container">
            <div class="player-select">
                <h3>Select Player 1</h3>
                <select id="player1-dropdown">
                    <option value=""></option>
                </select>
            </div>
            <div class="player-select">
                <h3>Select Player 2</h3>
                <select id="player2-dropdown">
                    <option value=""></option>
                </select>
            </div>
        </div>
        <div class="button-container">
            <button id="start-game-btn" disabled>Start Game</button>
        </div>
    </div>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let arenaState;

        const cellColors = {
            null: '#2a2a2a',
            '0': '#2a2a2a',
            '*': '#f2f2f2',
            '1': '#8e008e',
            '2': '#8e8e00',
            '-1': '#f2008d',
            '-2': '#8ef200',
        }

        window.addEventListener('resize', updateArena);
        class SpectatorClient {
            constructor() {
                this.ws = null;
                this.players = [];
                this.currentGame = null;
                this.selectedPlayer1 = null;
                this.selectedPlayer2 = null;

                // Add event listeners for dropdowns
                document.getElementById('player1-dropdown').addEventListener('change', (e) => {
                    this.selectPlayer(1, e.target.value);
                });
                document.getElementById('player2-dropdown').addEventListener('change', (e) => {
                    this.selectPlayer(2, e.target.value);
                });
            }

            connect() {
                this.ws = new WebSocket('ws://localhost:8080');

                this.ws.onopen = () => {
                    console.log('Connected to server');
                    this.register();
                };

                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleMessage(message);
                };

                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };

                this.ws.onclose = () => {
                    console.log('Disconnected from server');
                    // Retry connection after a delay
                    setTimeout(() => this.connect(), 5000);
                };
            }

            register() {
                const registerMessage = {
                    message_type: 'register',
                    client_type: 'Spectator',
                    client_name: 'Spectator',
                    client_id: null,
                    data: {}
                };
                this.ws.send(JSON.stringify(registerMessage));
            }

            handleMessage(message) {
                switch(message.type) {
                    case 'players_list':
                        this.players = message.players.map(player => ({
                            client_id: player.client_id,
                            player_name: player.player_name
                        }));

                        this.updateDropdowns();
                        break;
                    case 'game_state':
                        arenaState = message.data
                        this.updateGameState(message.game_state);
                        break;
                }
            }

            updateDropdowns() {
                const player1Dropdown = document.getElementById('player1-dropdown');
                const player2Dropdown = document.getElementById('player2-dropdown');

                // Clear existing options except the first one
                while (player1Dropdown.options.length > 1) {
                    player1Dropdown.remove(1);
                }
                while (player2Dropdown.options.length > 1) {
                    player2Dropdown.remove(1);
                }

                // Add new options
                this.players.forEach(player => {
                    // Add to player 1 dropdown
                    const option1 = new Option(`${player.player_name}`, player.client_id);
                    player1Dropdown.add(option1);

                    // Add to player 2 dropdown
                    const option2 = new Option(`${player.player_name}`, player.client_id);
                    player2Dropdown.add(option2);
                });

                // Check if currently selected players are still in the list
                if (!this.players.includes(this.selectedPlayer1)) {
                    this.selectedPlayer1 = null;
                    player1Dropdown.value = "";
                }
                if (!this.players.includes(this.selectedPlayer2)) {
                    this.selectedPlayer2 = null;
                    player2Dropdown.value = "";
                }

                this.updateStartButton();
            }

            selectPlayer(playerNumber, playerId) {
                if (playerNumber === 1) {
                    this.selectedPlayer1 = playerId || null;
                } else {
                    this.selectedPlayer2 = playerId || null;
                }
                this.updateStartButton();
            }

            updateStartButton() {
                const startButton = document.getElementById('start-game-btn');
                startButton.disabled = !(this.selectedPlayer1 && this.selectedPlayer2);
                startButton.onclick = () => {
                    if (this.selectedPlayer1 && this.selectedPlayer2) {
                        this.startGame(this.selectedPlayer1, this.selectedPlayer2);
                    }
                };
            }

            updateGameState(gameState) {
                this.currentGame = gameState;
                this.renderGame();
            }

            startGame(player1Id, player2Id) {
                const startGameMessage = {
                    message_type: 'start_game',
                    client_type: 'Spectator',
                    client_name: 'Spectator',
                    client_id: null,
                    data: {
                        player1: player1Id,
                        player2: player2Id
                    }
                };
                this.ws.send(JSON.stringify(startGameMessage));
            }

            renderGame() {
                updateArena()
            }
        }

        function drawCell(x, y, width, height, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);
        }

        function calcCellSize(height, cellCount) {
            return Math.floor(height / cellCount);
        }

        function drawText(text, x, y, fontSize) {
            ctx.fillStyle = '#fff';
            ctx.font = fontSize + 'px trebuchet ms';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(text, x, y);
        }

        function drawBackground() {
            ctx.fillStyle = '#151515';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawGrid(grid, width, height, cellSize, marginLeft=0, marginTop=0) {
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    let cell = null;
                    if (grid[y][x] != null)
                        cell = grid[y][x].toString();
                    drawCell(
                        x * cellSize + marginLeft,
                        y * cellSize + marginTop,
                        cellSize - 1,
                        cellSize - 1,
                        cellColors[cell],
                    );
                }
            }
        }

        function updateArena() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const playerInfoSize = Math.floor(canvas.height * 0.1);
            drawBackground();
            if (!arenaState)
                return;
            const arenaCellSize = Math.floor(
                (canvas.height - playerInfoSize) / arenaState['board']['size']);
            drawGrid(
                grid=arenaState['board']['board'],
                width=canvas.width,
                height=canvas.height - playerInfoSize,
                cellSize=arenaCellSize,
                marginLeft=(canvas.width - arenaCellSize * arenaState['board']['size']) / 2);

            const pieceCellSize = Math.floor(
                (canvas.height - arenaCellSize * arenaState['board']['size']) / arenaState['piece']['size']);
            drawGrid(
                grid=arenaState['piece']['piece'],
                width=canvas.width,
                height=canvas.height,
                cellSize=pieceCellSize,
                marginLeft=(canvas.width - pieceCellSize * arenaState['piece']['size']) / 2,
                marginTop=(height - pieceCellSize * arenaState['piece']['size']));

            // drawText(
            //     text=arenaState['player1']['name'] + ' - ' + arenaState['player1']['score'],
            //     x=canvas.width / 5,
            //     y=canvas.height - playerInfoSize,
            //     fontSize=playerInfoSize * 0.7);
            // drawText(
            //     text=arenaState['player2']['score'] + ' - ' + arenaState['player2']['name'],
            //     x=(canvas.width / 5) * 4,
            //     y=canvas.height - playerInfoSize,
            //     fontSize=playerInfoSize * 0.7);
        }

        // Création et initialisation du client
        const spectator = new SpectatorClient();
        updateArena()
        spectator.connect();
    </script>
</body>
</html>
